# SOLID

## SRP (단일 책임 원칙)

- 한 클래스는 하나의 책임만 가져야 한다.
  - 한 클래스를 변경하려는 이유는 하나만 있어야 한다.
  - 응집도를 높이고 결합도는 낮춘다. 코드 가독성을 높이고 유지보수를 용이하게 한다.

## OCP (개방-폐쇄 원칙)

- 소프트웨어의 구성요소는 확장에는 열려 있으나 수정에는 닫혀있어야 한다.
  - 수정할 것과 수정하지 않을 것을 구분하여 개발해야 된다.
  - 추상화는 개방-폐쇄 원칙의 핵심 요소이다.
    - 외부 모듈은 추상화에 의존함으로써 수정을 방지한다.
    - 추상화의 새 파생 클래스를 만들어서 확장할 수 있다.

## LSP (리스코프 치환 원칙)

- 프로그램의 정확성을 깨뜨리지 않으면서 객체를 하위 타입의 인스턴스로 치환할 수 있어야 한다.
  - 자식 클래스의 메소드가 부모 클래스의 기존 메소드의 의미를 해쳐서는 안된다.
  - 하위형에서 선행조건은 강화될 수 없다.
  - 하위형에서 후행조건은 약화될 수 없다.
  - 예시: 직사각형-정사각형 클래스의 너비, 높이 setter 문제
    - 정사각형 클래스는 너비와 높이를 다르게 설정하는 것을 허용하지 않는다.
    - 직사각형 클래스의 선행조건을 축소시키므로 LSP를 위반한다.

## ISP (인터페이스 분리 원칙)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 한 개보다 낫다.
  - 인터페이스의 단일 책임 원칙
  - 클래스는 꼭 필요한 인터페이스만 구현한다.
    - 시스템 내부 의존성을 약화시킨다.
    - 만약에라도 인터페이스를 수정할 시 코드 변경의 전파가 일어나는 파급 효과를 줄인다.

## DIP (의존관계 역전 원칙)

- 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 된다.
- 추상화는 세부 사항에 의존하면 안된다. 세부 사항이 추상화에 의존해야 된다.
- 세부 사항이 변해도 외부 모듈은 추상화에 의존하기 때문에 코드 변경의 전파를 막을 수 있다.
- 단, 추상화는 최대한 변하지 않도록 잘 정의한다. 추상화가 변경되면 그에 의존하는 모든 모듈에 변경이 필요하다.
- 의존성 주입(DI)은 이 원칙을 실천하기 위한 방법 중 하나다.